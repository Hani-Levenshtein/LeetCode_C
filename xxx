#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int maxline=10;//지하철 총 노선
typedef struct node {//지하철 역
	struct node* prev;//head쪽 역과 연결해줌
	struct node* next;//tail쪽 역과 연결해줌
	char name[21]; //역이름은 최대 20자
	int time; //역을 벗어나기위해 필요한 시간
}node;

typedef struct list {//호선
	struct node* head; //종착역
	struct node* tail; //종착역
}list;

node* getnode(node** newnode) {//지하철 역을 생성해줌
	(*newnode) = (node*)malloc(sizeof(node));//동적할당에서
	(*newnode)->prev = (*newnode)->next = NULL; //prev,next를 NULL초기화
	return (*newnode);//만든거 반환
}

void init(list* list) {//노선초기화
	list->head = getnode(&list->head);//헤드에 새노드
	list->tail = getnode(&list->tail);//테일에 새노드
	list->head->next = list->tail;//헤드를 테일에 묶어줌
	list->tail->prev = list->head;//테일을 헤드에 묶어줌
}

node* getstation(char name[], int time) {
	node* node = getnode(&node);
	strcpy(node->name, name);
	node->time = time;
	return node;
}

void addtohead(list* line, node* newnode) {
	newnode->prev = line->head; //
	newnode->next = line->head->next;//
	line->head->next->prev = newnode;//
	line->head->next = newnode;//
}
void addtotail(list* line, node* newnode) {
	newnode->prev = line->tail->prev; //
	newnode->next = line->tail;//
	line->tail->prev->next = newnode;//
	line->tail->prev = newnode;//
}

void add(list* line, char headortail[]) {//line 호선의 head나 tail에 역을 추가하는 함수
	char name[21]; //추가할 역 이름
	scanf("%s", &name);// 역 이름을 계속 입력
	if (strcmp(name, "stop") == 0) return;//stop이 입력될 때까지 입력.... 재귀함수 종료조건
	if (strcmp(headortail, "head") == 0) addtohead(line, getstation(name, rand() % 60 + 90));//입력받은 역과 랜덤한 90~150사이의 시간을 새역에 저장하고 head쪽에 추가
	else addtotail(line, getstation(name, rand() % 60 + 90));//입력받은 역과 랜덤한 90~150사이의 시간을 새역에 저장하고 tail쪽에 추가
	add(line,headortail); //재귀함수로 계속 반복 ->stop을 입력했으면 함수가 종료됨
}

void print(list* line) {//list 호선에 대하여
	node* p = line->head->next;//해당 호선의 첫번째 역으로 p를 설정
	for (;p->next != NULL;p = p->next) printf("%s ", p->name);//head와 tail사이의 모든 역을 순서대로 출력
	printf("\n");
}

node* search_station(list*line, char name[]) {//호선에 해당하는 역을 찾아주는 함수
	node* p = getnode(&p);//새노드만들어서
	p = line->head->next;//일단 p를 head쪽 종착역으로 설정해놓고
	if (p == NULL) return NULL;//비어있는 호선이면 바로NULL리턴
	for (;p != NULL;p=p->next) if(strcmp(p->name, name) == 0) return p;//아니면 역을 찾아서 반환해줌
	return NULL; //못찾았으면 NULL리턴해줌
}

void copypath(list* copy, list*original) {//copy 리스트에 original을 복사해줌
	node* p = original->head->next;//original의 첫번째역부터
	for (;p->next != NULL;p = p->next) addtotail(copy, getstation(p->name,p->time));//마지막까지 copy에 옮겨담음
}
void vaporization(list* line, node* node) {

}
int search_destination(list* line, char start[], char destination[],list* path) {//같은호선에서 start부터 destination까지의 루트를 알려줌

	node* st = search_station(line, start);//line호선에 start역이 있는지 확인
	if (st == NULL) return 2;//출발역이 없을때
	node* search = st;//출발역부터 도착역을 찾아주는 노드
	node* chase = st; //도착역을 찾았을때 출발역부터 도착역까지 걸어가는 노드
	for (;search->prev!=NULL;search = search->prev) {//head쪽 종착역을 탐색
		if (strcmp(destination, search->name) == 0) {//목적지가 탐색되면
			for (;chase!= search;chase = chase->prev) addtotail(path,getstation(chase->name,chase->time));//출발역부터 도착역전까지 경로에 저장해줌
			return 0;//끝냄
		}
	}
	for (search =st;search->next!=NULL;search = search->next) {//head쪽에 목적지가 없다면 tail쪽 종착역을 탐색
		if (strcmp(destination, search->name) == 0) {//목적지가 탐색되면
			for (chase = st;chase != search; chase = chase->next)addtotail(path, getstation(chase->name, chase->time));//출발역부터 도착역전까지 경로에 저장해줌
			return 0;//끝냄
		}
	}
	return 3;//출발역은 있지만 도착역은 없을때
}

void search_path(list* lines, char start[], char destination[], list* interchange, list* path) {//출발지에서 목적지까지 도달하는 것
	int stack = 0;//종료조건을위한 on off
	for (int i = 1;i <= maxline;i++) {//모든 호선을 탐색
		list* x = (list*)malloc(sizeof(list)); init(x); copypath(x,path);//x리스트를 생성하고 초기화한후 path를 복사받음
		if (search_destination(lines + i, start, destination, x) == 0) {//i호선에대하여 출발역과 도착역이 둘다 존재한다면
			node* p = x->head->next;//완성된path를 지나갈 새노드를 만들어놓음.
			int time = 0, count = 0;//time은 역을 지나면서 걸리는 시간을 모두 더해서 저장됨, count는 지나간 역의 개수를 저장함
			while (p->next!=NULL) { printf("%s ", p->name); time += p->time;count++;p = p->next; }//path가 끝날때까지 경로를 출력해주고, 시간과 역개수를 더해서 저장함
			printf("%s\n총 %2d 정거장이며 %2d분 %2d초가 소요됩니다.", destination,count, time / 60, time & 60);//마지막 목적지는 저장되어있지 않기에 따로 출력해주고 총정거장수, 소요시간을 출력해줌
			printf("\n---------------------------------------\n");//다른 경로와 구분지어주기 위한 라인
			stack = 1;//목적지를 찾았다면 1로 바뀜. for문의 종료조건이 아닌 이유는 search_path를 n번 실행했을때 n번째 실행에 목적지에 도착하는 경로가 2개 이상 있을수 있기때문
		}
		free(x);//목적지를 탐색한 경로는 목적지를 찾았던 못찾았던 리스트를 반환 // 이런 반환이 없다면 여러번 경로탐색을 못함
	}
	if (stack == 1) return;//목적지를 찾았다면 종료... 재귀함수 종료조건
	for (int i = 1;i <= maxline;i++) {
		node* search = interchange->head->next;
		for (;search->next!=NULL;search=search->next) {//모든 환승역에 대하여
			if (strcmp(search->name, "donotvisit") == 0) continue;//방문하지 않을 환승역은 제외하고
			list* x = (list*)malloc(sizeof(list)); init(x); copypath(x,path);

			if (search_destination(lines + i, start, search->name, x) == 0) {//출발역에서 환승역으로 이동시켰다면
				char newstart[21];//환승역 이름을
				strcpy(newstart, search->name);//임시 저장하고
				strcpy(search->name, "donotvisit");//다음에는 해당 이름을 가진 환승역을 방문하지 않기로하며
				search_path(lines, newstart, destination, interchange, x);//그 역으로 환승을 하고 다시 목적지를 재귀적으로 찾아본다.
				strcpy(search->name, newstart);
			}
			free(x);
		}
	}
}


char line_0[70][21] = {"신도림","대림","사당","교대","강남","선릉","종합운동장","잠실","건대입구","성수","왕십리","신당","동대문역사문화공원","을지로4가","을지로3가","시청","충정로","합정","당산","영등포구청"};

char line_2[70][21] = { "까치산","신도림","대림","낙성대","사당","서초","교대","강남","역삼","선릉","삼성","종합운동장","잠실새내","잠실","잠실나루","건대입구","성수","뚝섬","한양대","왕십리","상왕십리","신당","동대문역사문화공원","을지로4가","을지로3가","을지로입구","시청","충정로","홍대입구","합정","당산","영등포구청","문래","신도림" };
char line_3[70][21] = { "대화","주엽","정발산","마두","백석","대곡","삼송","연신내","불광","안국","종로3가","을지로3가","충무로","동국대","약수","압구정","고속터미널","교대","남부터미널","양재","매봉","도곡","대치","수서","가락시장","오금" };
char line_4[70][21] = { "산본","금정","범계","사당","이수","동작","이촌","신용산","삼각지","숙대입구","서울역","명동","충무로","동대문역사문화공원","동대문","혜화","성신여대입구","수유","창동","노원","당고개" };
char line_5[70][21] = {"방화","김포공항","까치산","영등포구청","영등포시장","신길","여의도","마포","공덕","애오개","충정로","광화문","종로3가","을지로4가","동대문역사문화공원","청구","신금호","행당","왕십리","마장","답십리","장한평","군자","천호","올림픽공원","오금","마천"};
char line_6[70][21] = { "응암","역촌","불광","독바위","연신내","응암","디지털미디어시티","합정","대흥","공덕","효창공원앞","삼각지","이태원","약수","청구","신당","동묘앞","보문","석계","태릉입구","신내" };
char line_7[70][21] = { "부평구청","온수","천왕","가산디지털단지","남구로","대림","숭실대입구","이수","내방","고속터미널","논현","강남구청","청담","건대입구","어린이대공원","군자","면목","상봉","먹골","태릉입구","공릉","노원","수락산","도봉산","장암" };
char line_8[70][21] = { "암사","천호","강동구청","몽촌토성","잠실","석촌","송파","가락시장","문정","장지","복정","산성","남한산성입구","단대오거리","모란" };
char line_9[70][21] = {"개화","김포공항","당산","여의도","샛강","노량진","흑석","동작","고속터미널","신논현","선정릉","봉은사","선정릉","종합운동장","석촌","올림픽공원","중앙보훈병원"};



int main() {
	int linenumber, menu; //호선, 메뉴

	list* lines = (list*)malloc(sizeof(list) * (10));//lines[0]은 환승역목록 / lines[1]~lines[9]는 호선으로 쓰기위해 lines[maxline+1]까지 동적할당
	for (int i = 0;i < 10;i++) init(lines + i);//각 노선마다 head와 tail을 달아준다
	/*
	for (int i = 0;i < 70;i++) addtotail(lines + 0, getstation(line_0[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 2, getstation(line_2[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 3, getstation(line_3[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 4, getstation(line_4[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 5, getstation(line_5[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 6, getstation(line_6[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 7, getstation(line_7[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 8, getstation(line_8[i], rand() % 60 + 90));
	for (int i = 0;i < 70;i++) addtotail(lines + 9, getstation(line_9[i], rand() % 60 + 90));
	*/
	while (1) {
		printf("\n0. 역 추가\n1. 환승설정 \n2. 노선도 출력\n3. 최단경로\n메뉴를 입력하세요 : ");
		scanf("%d", &menu);//메뉴입력
		switch (menu) { //menu값에 따라 switch-case
		case 0: { //역추가
			char HT[21];//역이름
			printf("[호선] [head or tail] [추가할 역 이름들] [stop]을 순서대로 입력하세요: ");
			scanf("%d %s", &linenumber, &HT);//호선과 head or tail
			add(lines + linenumber, HT);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 1: {
			char name[21] = "tail";//환승역은 리스트 개념이라 새로생기면 tail 쪽에 쌓아두는 형식
			printf("[추가할 역 이름들] [stop]을 입력하세요: ");
			add(lines + 0, name);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 2: {//지하철 노선도 출력
			printf("환승역 : ");
			print(lines + 0);//지하철의 모든 환승역을 출력해준다
			for (int i = 1;i < maxline;i++) { //모든 노선에 대하여
				printf("%d 호선 : ", i); //i번째 노선의
				print(lines + i);//모든 역을 head쪽부터 순서대로 출력해준다
			}
			break;
		}
		case 3: {
			printf("출발역과 도착역을 입력하세요 : ");
			char before[21], after[21];//before이 출발역 after가 도착역
			scanf("%s %s", &before, &after);//역을 입력하면
			printf("------------------------------------\n");

			list* interchange = (list*)malloc(sizeof(list));
			init(interchange);
			copypath(interchange,lines + 0);

			list* path = (list*)malloc(sizeof(list));
			init(path);
			search_path(lines, before, after, interchange, path);
			break;
		}

		}
	}
	return 0;
}
