#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int maxline;//지하철 총 노선
typedef struct node {//지하철 역
	struct node* prev;//head쪽 역과 연결해줌
	struct node* next;//tail쪽 역과 연결해줌
	char name[21]; //역이름은 최대 20자
	int time;
}node;

typedef struct list {//호선
	struct node* head; //종착역
	struct node* tail; //종착역
}list;

typedef struct path {
	struct route* head;
}path;

node* getnode(node** newnode) {//지하철 역을 생성해줌
	(*newnode) = (node*)malloc(sizeof(node));//동적할당에서
	(*newnode)->prev = (*newnode)->next = NULL; //prev,next를 NULL초기화
	return (*newnode);//만든거 반환
}

void init(list* list) {//노선초기화
	list->head = getnode(&list->head);//헤드에 새노드
	list->tail = getnode(&list->tail);//테일에 새노드
	list->head->next = list->tail;//헤드를 테일에 묶어줌
	list->tail->prev = list->head;//테일을 헤드에 묶어줌
}

void add(list* line, char headortail[]) {//line 호선의 head나 tail에 역을 추가하는 함수
	char name[21]; //추가할 역 이름
	scanf("%s", &name);// 역 이름을 계속 입력
	if (strcmp(name, "stop") == 0) return;//stop이 입력될 때까지
	node* newnode = getnode(&newnode);// stop이 아니면 새노드 만들어서
	strcpy(newnode->name, name);//역 이름 대입하고
	newnode->time = rand() % 60 + 90;//역을 통과하기 위한 시간을 랜덤으로 할당해줌
	if (strcmp(headortail, "tail") == 0) {//tail을 입력했으면 tail앞부분에 newnode를 넣어줌
		newnode->prev = line->tail->prev; //
		newnode->next = line->tail;//
		line->tail->prev->next = newnode;//
		line->tail->prev = newnode;//
	}
	else {//head를 입력했으면 head뒷부분에 newnode를 넣어줌
		newnode->prev = line->head; //
		newnode->next = line->head->next;//
		line->head->next->prev = newnode;//
		line->head->next = newnode;//
	}
	add(line,headortail); //재귀함수로 계속 반복 ->stop을 입력했으면 함수가 종료됨
}
void print(list* line) {//list 호선에 대하여
	node* p = line->head->next;//해당 호선의 첫번째 역으로 p를 설정
	for (;p->next != NULL;p = p->next) printf("%s ", p->name);//head와 tail사이의 모든 역을 순서대로 출력
	printf("\n");
}

node* search_station(list*line, char name[]) {//호선에 해당하는 역을 찾아주는 함수
	node* p = getnode(&p);//새노드만들어서
	p = line->head->next;//일단 p를 head쪽 종착역으로 설정해놓고
	if (p == NULL) return NULL;//비어있는 호선이면 바로NULL리턴
	for (;p != NULL;p=p->next) if(strcmp(p->name, name) == 0) return p;//아니면 역을 찾아서 반환해줌
	return NULL; //못찾았으면 NULL리턴해줌
}

void addtotail(list* path, node* info) {
	node* newnode = getnode(&newnode);//새노드 만들어서
	newnode->time = info->time;//시간정보를 얻고
	strcpy(newnode->name, info->name);//역이름을 얻어서 head뒤쪽에 newnode를 넣어줌
	newnode->prev = path->tail->prev;//
	newnode->next = path->tail;//
	path->tail->prev->next = newnode;//
	path->tail->prev = newnode;//


}

void copypath(list* original, list*copy) {
	node* p = original->head->next;
	for (;p->next != NULL;p = p->next) addtotail(copy, p);
}




int search_destination(list* line, char start[], char destination[],list* shortest) {//같은호선에서 start부터 destination까지의 루트를 알려줌

	node* st = search_station(line, start);//line호선에 start역이 있는지 확인
	if (st == NULL) return 2;//없으면 끝냄
	node* ch = st;
	node* se = st;
	for (;ch->prev!=NULL;ch = ch->prev) {//head쪽 종착역을 탐색
		if (strcmp(destination, ch->name) == 0) {//목적지가 탐색되면
			for (;se != ch;se = se->prev) addtotail(shortest, se);
			return 0;//끝냄
		}
	}

	for (se=ch=st;ch->next!=NULL;ch = ch->next) {//head쪽에 목적지가 없다면 tail쪽 종착역을 탐색
		if (strcmp(destination, ch->name) == 0) {//목적지가 탐색되면
			for (;se != ch;se = se->next)  addtotail(shortest, se);
			return 0;//끝냄
		}
	}
	return 3;
}
void shortestpath(list* lines, char start[], char destination[], list* interchange, list* shortest) {//출발지에서 목적지까지 도달하는 것
	int stack = 0;
	for (int i = 1;i <= maxline;i++) {
		list* x = (list*)malloc(sizeof(list)); init(x); copypath(shortest, x);
		if (search_destination(lines + i, start, destination, x) == 0) {
			node* p = getnode(&p);
			int time = 0, count = 0;
			p = x->head->next;
			while (p->next!=NULL) { printf("%s ", p->name); time += p->time;count++;p = p->next; }
			printf("%s\n총 %2d 정거장이며 %2d분 %2d초가 소요됩니다.", destination,count, time / 60, time & 60);
			printf("\n---------------------------------------\n");
			stack = 1;
		}
		free(x);
	}
	if (stack == 1) return;
	for (int i = 1;i <= maxline;i++) {
		node* search = interchange->head->next;
		for (;search->next!=NULL;search=search->next) {//모든 환승역에 대하여
			if (strcmp(search->name, "donotvisit") == 0) continue;//방문하지 않을 환승역은 제외하고
			list* x = (list*)malloc(sizeof(list)); init(x); copypath(shortest, x);

			if (search_destination(lines + i, start, search->name, x) == 0) {//출발역에서 환승역으로 이동시켰다면
				char newstart[21];//환승역 이름을
				strcpy(newstart, search->name);//임시 저장하고
				strcpy(search->name, "donotvisit");//다음에는 해당 이름을 가진 환승역을 방문하지 않기로하며
				shortestpath(lines, newstart, destination, interchange, x);//그 역으로 환승을 하고 다시 목적지를 재귀적으로 찾아본다.
				strcpy(search->name, newstart);
			}
			free(x);
		}
	}
}

int main() {
	int linenumber, menu; //호선, 메뉴
	printf("총 몇 호선을 만들지 입력하세요 : ");
	scanf("%d", &maxline);
	getchar();
	list* lines = (list*)malloc(sizeof(list) * (maxline + 1));//lines[0]은 환승역목록 / lines[1]~lines[9]는 호선으로 쓰기위해 lines[maxline+1]까지 동적할당
	for (int i = 0;i <= maxline;i++) init(lines + i);//각 노선마다 head와 tail을 달아준다
	while (1) {
		printf("\n0. 역 추가\n1. 환승설정 \n2. 노선도 출력\n3. 최단경로\n메뉴를 입력하세요 : ");
		scanf("%d", &menu);//메뉴입력
		switch (menu) { //menu값에 따라 switch-case
		case 0: { //역추가
			char HT[21];//역이름
			printf("[호선] [head or tail] [추가할 역 이름들] [stop]을 순서대로 입력하세요: ");
			scanf("%d %s", &linenumber, &HT);//호선과 head or tail
			add(lines + linenumber, HT);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 1: {
			char name[21] = "tail";//환승역은 리스트 개념이라 새로생기면 tail 쪽에 쌓아두는 형식
			printf("[추가할 역 이름들] [stop]을 입력하세요: ");
			add(lines + 0, name);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 2: {//지하철 노선도 출력
			printf("환승역 : ");
			print(lines + 0);//지하철의 모든 환승역을 출력해준다
			for (int i = 1;i <= maxline;i++) { //모든 노선에 대하여
				printf("%d 호선 : ", i); //i번째 노선의
				print(lines + i);//모든 역을 head쪽부터 순서대로 출력해준다
			}
			break;
		}
		case 3: {
			printf("출발역과 도착역을 입력하세요 : ");
			char before[21], after[21];//before이 출발역 after가 도착역
			scanf("%s %s", &before, &after);//역을 입력하면
			printf("------------------------------------\n");

			list* interchange = (list*)malloc(sizeof(list));
			init(interchange);
			copypath(lines + 0,interchange);

			list* shortest = (list*)malloc(sizeof(list));
			init(shortest);

			shortestpath(lines, before, after, interchange,shortest);
			break;
		}
		case 4: {





		}
		}
	}
	return 0;
}
