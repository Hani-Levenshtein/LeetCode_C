#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int maxline;//지하철 총 노선
typedef struct node {//지하철 역
	struct node* prev;//head쪽 역과 연결해줌
	struct node* next;//tail쪽 역과 연결해줌
	char name[21]; //역이름은 최대 20자
	int time;
}node;

typedef struct list {//호선
	struct node* head; //종착역
	struct node* tail; //종착역
}list;

node* getnode(node** newnode) {//지하철 역을 생성해줌
	(*newnode) = (node*)malloc(sizeof(node));//동적할당에서
	(*newnode)->prev = (*newnode)->next = NULL; //prev,next를 NULL초기화
	return (*newnode);//만든거 반환
}

void init(list* list) {//노선초기화
	list->head = getnode(&list->head);//헤드에 새노드
	list->tail = getnode(&list->tail);//테일에 새노드
	list->head->next = list->tail;//헤드를 테일에 묶어줌
	list->tail->prev = list->head;//테일을 헤드에 묶어줌
}

void add(list* line, char headortail[]) {//line 호선의 head나 tail에 역을 추가하는 함수
	char name[21]; //추가할 역 이름
	scanf("%s", &name);// 역 이름을 계속 입력
	if (strcmp(name, "stop") == 0) return;//stop이 입력될 때까지
	node* newnode = getnode(&newnode);// stop이 아니면 새노드 만들어서
	strcpy(newnode->name, name);//역 이름 대입하고
	newnode->time = rand() % 60 + 90;//역을 통과하기 위한 시간을 랜덤으로 할당해줌
	if (strcmp(headortail, "tail") == 0) {//tail을 입력했으면
		newnode->prev = line->tail->prev; //
		newnode->next = line->tail;//
		line->tail->prev->next = newnode;//
		line->tail->prev = newnode;//
	}
	else {//head를 입력했으면
		newnode->prev = line->head; //
		newnode->next = line->head->next;//
		line->head->next->prev = newnode;//
		line->head->next = newnode;//
	}
	add(line,headortail); //재귀함수로 계속 반복 ->stop을 입력했으면 함수가 종료됨
}
void print(list* line) {//list 호선에 대하여
	node* p = line->head->next;//해당 호선의 첫번째 역으로 p를 설정
	for (;p->next != NULL;p = p->next) printf("%s ", p->name);//head와 tail사이의 모든 역을 순서대로 출력
	printf("\n");
}

node* search_station(list*line, char name[]) {//호선에 해당하는 역을 찾아주는 함수
	node* p = getnode(&p);//새노드만들어서
	p = line->head->next;//일단 p를 head쪽 종착역으로 설정해놓고
	if (p == NULL) return NULL;//비어있는 호선이면 바로NULL리턴
	for (;p != NULL;p=p->next) if(strcmp(p->name, name) == 0) return p;//아니면 역을 찾아서 반환해줌
	return NULL; //못찾았으면 NULL리턴해줌
}

int search_destination(list* line, char start[], char destination[]) {//같은호선에서 start부터 destination까지의 루트를 알려줌
	node* p= search_station(line, start);//line호선에 start역이 있는지 확인
	if (p == NULL) return 2;//없으면 반환
	node* q = p; //위에서 리턴되지않았다면 p는 start위치에 있고, 따라서 q로 start에서 destination을 탐색
	node* chase = p;//chase는 목적지를 찾았을떄, start에서 출발하는 노드포인터
	int count = 0;//start에서 destination으로 도달하기 위한 정거장 개수
	int time = 0;
	for (;q != line->head;q = q->prev, count++) {//head쪽 종착역을 탐색
		if (strcmp(destination, q->name) == 0) {//목적지가 탐색되면
			for (int i = 0;i <= count;i++, time+=chase->time,chase = chase->prev)//출발지부터 목적지까지
				printf("%s ", chase->name);//역 이름을 출력해줌
			printf("\n%02d분 %02d초 소요되며 총 %d정거장 입니다\n", time/60, time%60, count);
			return 0;//끝냄
		}
	}
	;//tail쪽 종착역을 탐색하기위해 초기화
	for (count = 0, q = p ;q != line->tail;q = q->next, count++) {//tail쪽 종착역을 탐색
		if (strcmp(destination, q->name) == 0) {//목적지가 탐색되면
			for (int i = 0;i <= count;i++, time += chase->time, chase = chase->next)//출발지부터 목적지까지
				printf("%s ", chase->name);//역 이름을 출력해줌
			printf("\n%02d분 %02d초 소요되며 총 %d정거장 입니다\n", time / 60, time % 60, count);
			return 0;//끝냄
		}
	}
	return 3;
}
void shortestpath(list* lines, char start[], char destination[], char** interchange) {//출발지에서 목적지까지 도달하는 것

	int stack = 0;//목적지에 도달했는지 알려주는 기능
	for (int i = 1;i <= maxline;i++) //모든 호선에 대하여
		if (search_destination(lines+i, start, destination) == 0) stack=1; //목적지에 도달했다면 stack이 on 상태
	if (stack == 1 || strcmp(start,destination)==0) { printf("------------------------------------\n");return;}//목적지에 도달했으니 함수가 종료됨

	for (int i = 1;i <= maxline;i++){//모든 노선에 대하여
		for (int j=0;j<(int)_msize(interchange)/(int)sizeof(char);j++)//모든 환승역에 대하여
			if (search_destination(lines + i, start,*(interchange +j)) == 0) {//출발역에서 환승역으로 이동시켰다면
				char newstart[21];//환승역 이름을
				strcpy(newstart, *(interchange + j));//임시 저장하고
				strcpy(*(interchange + j),"");//다음에는 해당 이름을 가진 환승역을 방문하지 않기로하며
				shortestpath(lines, newstart, destination, interchange);//그 역으로 환승을 하고 다시 목적지를 재귀적으로 찾아본다.
				strcpy(*(interchange + j), newstart);
			}
	}
}

int main() {
	int linenumber, menu; //호선, 메뉴
	printf("총 몇 호선을 만들지 입력하세요 : ");
	scanf("%d", &maxline);
	getchar();
	list* lines = (list*)malloc(sizeof(list) * (maxline + 1));//lines[0]은 환승역목록 / lines[1]~lines[9]는 호선으로 쓰기위해 lines[maxline+1]까지 동적할당
	for (int i = 0;i <= maxline;i++) init(lines + i);//각 노선마다 head와 tail을 달아준다
	while (1) {
		printf("\n0. 역 추가\n1. 환승설정 \n2. 노선도 출력\n3.최단경로\n메뉴를 입력하세요 : ");
		scanf("%d", &menu);//메뉴입력
		switch (menu) { //menu값에 따라 switch-case
		case 0: { //역추가
			char HT[21];//역이름
			printf("[호선] [head or tail] [추가할 역 이름들] [stop]을 순서대로 입력하세요: ");
			scanf("%d %s", &linenumber, &HT);//호선과 head or tail
			add(lines + linenumber, HT);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 1: {
			char name[21] = "tail";//환승역은 리스트 개념이라 새로생기면 tail 쪽에 쌓아두는 형식
			printf("[추가할 역 이름들] [stop]을 입력하세요: ");
			add(lines + 0, name);//함수안에서 역 이름과 stop을 입력할 수 있도록 되어있음
			break;
		}
		case 2: {//지하철 노선도 출력
			printf("환승역 : ");
			print(lines + 0);//지하철의 모든 환승역을 출력해준다
			for (int i = 1;i <= maxline;i++) { //모든 노선에 대하여
				printf("%d 호선 : ", i); //i번째 노선의
				print(lines + i);//모든 역을 head쪽부터 순서대로 출력해준다
			}
			break;
		}
		case 3: {
			printf("출발역과 도착역을 입력하세요 : ");
			char before[21], after[21];//before이 출발역 after가 도착역
			scanf("%s %s", &before, &after);//역을 입력하면
			printf("------------------------------------\n");
			char** interchange = (char**)malloc(sizeof(char*));
			node* p = (lines + 0)->head->next;
			for (int i = 0;p!= (lines+0)->tail;i++, p = p->next) {
				*(interchange + i) = (char*)malloc(sizeof(char) * 21);
				strcpy(*(interchange + i), p->name);
			}
			shortestpath(lines, before, after, interchange);
			break;
		}
		}
	}
	return 0;
}
